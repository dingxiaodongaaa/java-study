## 接口

接口就是一种公共的规范标准，只要符合规范标准，就可以大家通用

- 接口就是多个类的公共规范
- 接口时一种引用数据类型，最重要的内容就是其中的：抽象方法
- 定义一个接口的格式

```java
public interface 接口名称 {
  // 接口内容
}
```

### 备注

1. 换成关键字 interface 之后，编译生成的字节码文件仍然是 .java ---> .class
2. 如果是 Java7 那么接口中可以包含

- 常量
- 抽象方法

3. 如果是 Java 8 还可以额外包含

- 默认方法
- 静态方法

4. 如果是 Java 9 还可以额外包含

- 私有方法

### 接口的使用步骤

1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口
   格式：

```java
public class 实现类名称 implements 接口名称 {
  // ...
}
```

2. 接口的实现类必须覆盖重写接口中所有的抽象方法
   实现： 去掉 abstract 关键字，加上方法体大括号
3. 创建实现类的对象，进行使用

### 注意事项

1. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是一个抽象类

### 接口的默认方法定义

从 Java 8 开始，接口里面允许定义默认方法
格式：

```java
public default 返回值类型 方法名称(参数列表) {
  方法体
}
```

备注：接口当中的默认方法，可以解决接口升级的问题

1.  接口的默认方法，可以通过接口实现类对象，直接调用
2.  接口的默认方法，也可以被接口的实现类进行覆盖重写

### 接口的静态方法定义

从 Java 8 开始，接口里面允许定义静态方法
格式：

```java
public static 返回值类型 方法名称(参数列表) {
  方法体
}
```

提示：就是将 abstract 或者 default 换成 static 即可，带上方法体

1. 不能通过接口实现类的对象来调用接口当中的静态方法
   _通过接口名称直接调用器中的静态方法_

### 接口的私有方法定义

当接口中存在需要抽象的公共逻辑，并且这块逻辑是不需要提供给接口实现类的方法，就可以把这个抽象成接口的私有方法，仅供接口的静态、默认、抽象方法调用

从 Java 9 开始，接口当中允许定义私有方法

1. **普通私有方法**，解决多个默认方法之间重复代码问题

格式：

```java
private 返回值类型 方法名(参数列表) {
  方法体
}
```

2. **静态私有方法**，解决多个静态方法之间重复代码问题

格式：

```java
private static 返回值类型 方法名(参数列表) {
  方法体
}
```

### 接口的常量定义和使用

接口当中也可以定义 “成员变量”，但是必须使用 public static final 三个关键词修饰

从效果上看，这其实就是接口的**常量**

格式：

```java
public static final 数据类型 常量名称 = 数据值;
```

一旦使用 final 关键词进行修饰，说明不可改变

1. 接口当中的常量，可以省略 public static final 注意：默认就是这三个关键字，即便不屑
2. 接口当中的常量，必须进行赋值，不能不赋值
3. 接口常量的名称，使用完全大写的字母，用下划线进行分割

### 注意事项

1. 接口时没有静态代码块或者构造方法的
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
   格式：

```java
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
  // 覆盖重写所有的抽象方法
}
```

3. 如果多个接口中有重复的抽象方法，实现类中只需要重写一次即可
4. 如果实现类没有覆盖重写所有的接口的所有抽象方法，那这个实现类必须是一个抽象类
5. 如果实现类实现的多个接口中，存在重复的默认方法， 那么实现类一定要对冲突的默认方法进行覆盖冲洗
6. 一个类如果直接父类当中的方法，和接口类中的默认方法产生了冲突，优先用父类中定义的方法

### 接口之间的多继承

1. 类与类之间是单继承的，直接父类只有一个
2. 类与接口之间是多实现的，一个类可以实现多个接口
3. 接口与接口之间是多继承的

#### 注意事项

1. 多个父接口当中的抽象方法如果重复，没关系
2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写【而且带着 default 关键字】
